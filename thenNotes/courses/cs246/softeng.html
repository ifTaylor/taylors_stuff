<!DOCTYPE html>
<html>
  <head>
    <title>CS 246 :: Software Engineering</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, shrink-to-fit=no, initial-scale=1">
    <meta name="Course Notes" content="">
    <meta name="Raphael" content="">

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/simple-sidebar.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=cpp&lang=bsh&skin=sunburst"></script>
  </head>
  <body>
    <div id="wrapper">
      <!-- Sidebar -->
      <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
          <li class="sidebar-brand">
            <a href="./home.html">CS 246 Home</a>
          </li>
          <li><a href="#1">Testing</a></li>
          <li><a href="#2">Coupling and Cohesion</a></li>
          <li><a href="#3">Design Patterns</a></li>
          <li><a href="#4">Observer Pattern</a></li>
          <li><a href="#5">Decorator Pattern</a></li>
          <li><a href="#6">Factory Method Pattern</a></li>
          <li><a href="#7">Template Method Pattern</a></li>
          <li><a href="#8">Non-Virtual Interface(NVI) Idiom</a></li>
          <li><a href="#9">Visitor Pattern</a></li>
          <li><a href="#10">PImpl Idiom</a></li>
          <li><a href="#11">Model-View-Controller(MVC) Pattern</a></li>
          <li><a href="#12">Strategy Pattern</a></li>
        </ul>
      </div>
      <!-- /#sidebar-wrapper -->

      <!-- Page Content -->
      <div id="page-content-wrapper">
          <div class="container-fluid">
            <div class="row">
              <div class="col-lg-12">
                <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toggle Menu</a>
                <h1 id="title_text">Software Engineering</h1><br />

                <!-- Table of Contents -->
                <div id="contents">
                  <h1>Table of Contents</h1>
                  <ol id="nav">
                    <li><a href="#1">Testing</a></li>
                    <li><a href="#2">Coupling and Cohesion</a></li>
                    <li><a href="#3">Design Patterns</a></li>
                    <li><a href="#4">Observer Pattern</a></li>
                    <li><a href="#5">Decorator Pattern</a></li>
                    <li><a href="#6">Factory Method Pattern</a></li>
                    <li><a href="#7">Template Method Pattern</a></li>
                    <li><a href="#8">Non-Virtual Interface(NVI) Idiom</a></li>
                    <li><a href="#9">Visitor Pattern</a></li>
                    <li><a href="#10">PImpl Idiom</a></li>
                    <li><a href="#11">Model-View-Controller(MVC) Pattern</a></li>
                    <li><a href="#12">Strategy Pattern</a></li>
                  </ol>
                </div>
                <!--Table of Contents -->

                  <h2 id="1">Testing</h2>
                  Why we test?
                  <ol>
                    <li>Make judgement about quality or acceptability of program</li>
                    <li>To discover errors</li>
                  </ol>
                  Goals of Test:
                  <ol>
                    <li>Find failure</li>
                    <li>Demonstrate correct execution</li>
                  </ol>
                  <b>Deficient fix</b>: when a fix causes previously correct software to misbehave
                  <h3 style="margin-bottom:0;">Test Case</h3>
                  - essence of software testing to determine a set of test cases for the item to be tested
                  <ul>
                    <li>Specification-based Testing</li>
                    <ul>
                      <li>programs can be considered functions that map values from input domain to values in its output range</li>
                      <li>black box testing</li>
                      <li>content of black box is not known</li>
                      <li>only understand input and output</li>
                      <li>Advantages:</li>
                      <ol>
                        <li>Independent of how software is implemented</li>
                        <li>Test case development occur in parallel with implementation</li>
                      </ol>
                      <li>Disadvantages:</li>
                      <ol>
                        <li>Significant redundancies</li>
                        <li>Gaps of untested software</li>
                      </ol>
                    </ul>
                    <li>Code-based Testing</li>
                      <ul>
                        <li>white box testing</li>
                        <li>implementation is known</li>
                        <li>if program implements a behaviour not specified, this will never be revealed</li>
                      </ul>
                  </ul>
                  <h3 style="margin-bottom:0;">How to Test</h3>
                  <ul>
                    <li>Start with black box testing because it is only dependent on the specification not the implementation</li>
                    <li>Supplement with white box: cover several places in your program</li>
                    <li>Black Box Testing</li>
                    <ul>
                      <li>Test the boundaries of valid input (edge cases)</li>
                      <li>Multiple simultaneous boundaries</li>
                      <li>Experienced tester will be able to guess what type of input is more likely to generate an error</li>
                      <li>Test extreme cases</li>
                    </ul>
                    <li>White Box Testing</li>
                    <ul>
                      <li>Execute all lines of code</li>
                      <li>Execute all logical paths</li>
                      <li>Check that all functions run</li>
                    </ul>
                    <li>Regression Testing</li>
                    <ul>
                      <li>New changes do not cause previous code to break</li>
                      <li>Run a set of test suites and testing scripts that contain previously checked tests after each addition of the code or bfore every release</li>
                    </ul>
                  </ul>

                  <h2 id="2">Coupling and Cohesion</h2>
                  <b>Coupling</b> and <b>cohesion</b> are 2 measures of design quality.
                  <h3>Coupling</h3>
                  Coupling measures the degree of interdependence between software modules.  A <i>lower</i> coupling is better.  A high coupling is bad because:
                  <ol>
                    <li>Changes to one module require greater changes to other modules</li>
                    <li>Harder to reuse individual modules</li>
                  </ol>
                  <h4>Low to High Coupling</h4>
                  <ol>
                    <li>Modules communicate via function calls with basic parameters returns</li>
                    <li>Modules pass arrays/structs back and forth</li>
                    <li>Module affect each others control flow</li>
                    <li>Modules share global data</li>
                    <li>Modules have access to each others implementation (friends)</li>
                  </ol>

                  <h3>Cohesion</h3>
                  Cohesion measures how closely elements of a module are related to each other.  A <i>higher</i> cohesion is better.  A low cohesion is bad because:
                  <ol>
                    <li>Sign of poorly organized code</li>
                    <li>Hard to understand and maintain</li>
                    <li>Has many operations that don't have much in common</li>
                  </ol>
                  <h4>High to Low Cohesion</h4>
                  <ol>
                    <li>Elements cooperate to perform exactly one task</li>
                    <li>Elements pass data to each other</li>
                    <li>Elements maniplate a state over lifetime of an object, e.g. open/read/close files</li>
                    <li>Elements have a common theme, otherwise unrelated, perhaps share base code, e.g. &lt;algorithm></li>
                    <li>Arbitrary grouping of unrelated elements, e.g. &lt;utility></li>
                  </ol>


                  <h2 id="3">Design Patterns</h2>
                  Software <b>design patterns</b> are general reusable solutions to commonly occurring problems within a given context in software design. For example, using the concept of iterators with Linked Lists.
<pre class="prettyprint">
class List {
  struct Node;
  Node *list = nullptr;
public:
  class Iterator {
    Node *p;
  public:
    explicit Iterator(Node *p) : p{p} {};
    int &operator*(){
      return p->data;
    }
    Iterator &operator++() {
      p = p->next;
      return *this;
    }
    bool operator ==(const Iterator &other) const {
      return p == other.p;
    }
    bool operator !=(const Iterator &other) const {
      return !(*this == other);
    }
    Iterator begin() {
      return Iterator(list);
    }
    Iterator end() {
      return Iterator(nullptr);
    }
  }
}

List lst;
lst.addToFront(1);
lst.addToFront(2);
lst.addToFront(3);

for (auto it = lst.begin(); it != lst.end; ++it){
  cout << *it << end;
}
// OR
for (auto n : lst) {
  cout << n << endl;
}</pre>

                <h2 id="4">Observer Pattern</h2>
                <img src="../images/observer.png" /><br />
                The <b>observer pattern</b> is used to establish a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.  The general structure has:
                <ol>
                  <li>
                    AbstractSubject
                    <ul>
                      <li>keeps tracks of observers</li>
                      <li>allows adding and removing of observers</li>
                      <li>notifies observers when subject's state changes</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteSubject
                    <ul>
                      <li>the "real" class that implements <code>AbstractSubject</code></li>
                      <li>its change will notify the observers</li>
                    </ul>
                  </li>
                  <li>
                    AbstractObserver
                    <ul>
                      <li>an abstract class that defines the method that should be called whenever there is a change.</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteObserver
                    <ul>
                      <li>the class that needs to keep itself updated with changes.</li>
                      <li>implements <code>AbstractObserver</code></li>
                      <li>registers itself with the <code>ConcreteSubject</code></li>
                    </ul>
                  </li>
                </ol>
                For example, the observer pattern could be used to keep track of a product's price, and any change to its price will update the various stores that sell it. In this case:
                <ol>
                  <li>
                    Subject: Product
                  </li>
                  <li>
                    Observers: Stores
                  </li>
                  <li>
                    When price updates, it calls <code>notifyObservers()</code> which calls <code>notify()</code> on each store.
                  </li>
                </ol>
<pre class="prettyprint">
// AbstractSubject
class Subject {
  std::vector&lt;Shop*> observers;
public:
  void attach(Observer* o) { observers.push_back(o); }
  void detach(Observer* o) {
    list.erase(std::remove(list.begin(), list.end(), o), list.end());
  }
  void notifyObservers(float price) {
    for (auto o : observers) {
      o->notify(price);
    }
  }
}

// ConcreteSubject
class Product : public AbstractSubject {
public:
  void updatePrice(float price) { notifyObservers(price); }
}

// AbstractObserver
class Observer {
public:
    virtual void notify(float price) = 0;
}

// ConcreteObserver
class Shop : public Observer {
  std::string name;
  float price;
public:
  Shop(std::string name) : name { name } {}
  void notify(float price) { this->price = price; }
}

int main() {
  Product p;
  Shop shop1("Shop1");
  Shop shop2("Shop2");

  // attach observers
  p.attach(shop1);
  p.attach(shop2);

  // update price and notify observers
  p.updatePrice(2.35);

  // Shop2 not looking to update price, so they unsubscribe
  p.detach(shop2);

  // only Shop1 is updated now
  p.updatePrice(2.30);
}
</pre>

                <h2 id="5">Decorator Pattern</h2>
                <img src="../images/decorator.png" /><br />
                The <b>decorator pattern</b> is used to attach responsibilities to an object dynamically.  Inheritance is not feasible as it is static and applies to the entire class.  The decorator pattern provides a flexible alternative to subclassing for extending functionality.  It is dynamic and is applied to individual objects.  The general structure has:
                <ol>
                  <li>
                    Component
                    <ul>
                      <li>"lowest common denominator"</li>
                      <li>abstract class for "base object" and the decorators</li>
                      <li>can be used on its own or wrapped by decorator</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteComponent
                    <ul>
                      <li>implements <code>Component</code></li>
                      <li>the object we're adding functionalities to</li>
                    </ul>
                  </li>
                  <li>
                    Decorator
                    <ul>
                      <li>the extra functionality</li>
                      <li>implements <code>Component</code> (same as ConcreteComponent)</li>
                      <li>has a pointer to a component</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteDecorator
                    <ul>
                      <li>the extra functionality</li>
                      <li>implements <code>Component</code> (same as ConcreteComponent)</li>
                      <li>one is defined for each optional functionality</li>
                      <li>implements their "added functionality" and delegates it to the Decorator base class</li>
                    </ul>
                  </li>
                </ol>
<pre class="prettyprint">
// Lowest common denominator
class Pizza {
public:
  virtual std::string description() = 0;
  virtual ~Pizza() {};
};

// ConcreteComponent (base object)
class CrustAndSauce: public Pizza {
 public:
 // virtual method (override)
  std::string description() { return "Pizza"; }
};

// Decorator
class Decorator: public Pizza {
 protected:
  Pizza *component;
 public:
  Decorator(Pizza *component) : component{ component } {}
  Decorator::~Decorator() { delete component; }
};

// Decorator 1
class StuffedCrust: public Decorator {
 public:
  StuffedCrust(Pizza *component) : Decorator{ p } {}
  // virtual
  std::string description() {
    // delegation to component and add extra functionality
    return component->description() + " with stuffed crust";
  }
};
// Decorator 2
class DippingSauce: public Decorator {
  std::string flavour;
 public:
  DippingSauce(std::string flavour, Pizza *component) :
    Decorator{ p }, flavour{ flavour } {}
  // virtual
  std::string description() {
    // delegation to component and add extra functionality
    return component->description() + " with " + flavour + " dipping sauce";
  }
};

int main() {
  Pizza *p = new StuffedCrust(
              new DippingSauce("BBQ",
                new DippingSauce("Garlic",
                  new CrustAndSauce)));
  cout << p->description();
  // Output: "Pizza with Garlic dipping sauce with BBQ dipping sauce with stuffed crust"
}
</pre>

                <h2 id="6">Factory Method Pattern</h2>
                <a href="https://sourcemaking.com/design_patterns/factory_method"><img src="../images/factory.png" /></a><br />
                The <b>Factory Method Pattern</b> uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object being created.  It allows classes to defer instantiation it uses to subclasses.   The general structure has:
                <ol>
                  <li>
                    AbstractProduct
                    <ul>
                      <li>Contains the factory method that creates the required subclass.  Commonly implemented as a <code>static</code> function.</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteProduct
                    <ul>
                      <li>The concrete subclasses that are actually returned.</li>
                    </ul>
                  </li>
                </ol>
<pre class="prettyprint">
// AbstractProduct
class Enemy {
public:
  // factory method
  static Enemy *createEnemy(const std::string type) {
    if (type == "turtle") return new Turtle;
    if (type == "bullet") return new Bullet;
    return NULL;
};

// ConcreteProduct
class Turtle : public Enemy {}
class Bullet : public Enemy {}

int main() {
  Enemy *e = Enemy::createEnemy(turtle);
  return 0;
}
</pre>
                <h2 id="7">Template Method Pattern</h2>
                <a href="http://www.codeguru.com/cpp/article.php/c17909/C-Tutorial-The-Template-Pattern.htm"><img src="../images/template.png" /></a><br />
                The <b>template method pattern</b> defines the skeleton of an algorithm in a "template method".  It defers some steps to subclasses to override by creating "placeholders".  The derived classes then override these placeholders to complete the algorithm.  The general structure has:
                <ol>
                  <li>
                    AbstractClass
                    <ul>
                      <li>contains the template method</li>
                      <li>contains abstract versions of the placeholder operations</li>
                    </ul>
                  </li>
                  <li>
                    ConcreteClass
                    <ul>
                      <li>each ConcreteClass implements the full version of the algorithm by overriding all placeholder functions</li>
                    </ul>
                  </li>
                </ol>
<pre class="prettyprint">
// AbstractClass
class Turtle {
public:
// template method
  void draw() {
    drawHead();
    drawShell();
    drawFeet();
  }
private:
  void drawHead() {}
  void drawFeet() {}
  // placeholder method
  virtual void drawShell = 0;
}

// ConcreteClassA
class RedTurtle : public Turtle {
  // override placeholder
  void drawShell override {
    // draw red shell
  }
}

// ConcreteClassB
class GreenTurtle : public Turtle {
  // override placeholder
  void drawShell override {
    // draw green shell
  }
}</pre>
                <h2 id="8">Non-Virtual Interface(NVI) Idiom</h2>
                Public virtual functions have the following uses:
                <ol>
                  <li>
                    Provides an interface to client.  Indicates provided behaviour.
                  </li>
                  <li>
                    Provides an interface to subclasses.  Contains "hooks" for subclasses to insert specialized behaviour
                  </li>
                </ol>
                If public virtual functions are wrapped in the function declaration, it would be difficult to separate (modularize) them.  <br />
                Furthermore, as discussed in <a href="./class.html#19">another section</a>, pre and postconditions are useful to ensure that the class invariants are not violated during the execution of a program.  It is important to modularize so we don't have repetitive checking of pre/post conditions and, potentially, forgetting to check them.  It is useful to check them in one place, the base class.  This is what the <b>NVI</b> idiom tries to accomplish. It separates customizable behaviour as private methods with non-customizable steps in between without changing public interface.  Here are its guidelines:
                <ol>
                  <li>All public methods should be non-virtual, using the Template Design Pattern</li>
                  <li>All virtual methods should be private (ideally except in the following case)</li>
                  <li>If derived classes need to invoke the base implementation of a virtual method, we make it protected.</li>
                  <li>Base class destructor should be either public and virtual, or protected and nonvirtual.</li>
                </ol>
<pre class="prettyprint">
// Without NVI Idiom
class DigitalMedia {
public:
  virtual void play() = 0;
  virtual ~DigitalMedia;
}

// With NVI Idiom
class DigitalMedia {
public:
  void play() {
    doPlay();
  }
  virtual ~DigitalMedia();
private:
  virtual void doPlay() = 0;
}</pre>
                Advantages of NVI Idiom in above example:
                <ul>
                  <li>extra control over Play</li>
                  <li>we can add before/after code around doPlay that cant change</li>
                  <li>we can add more "hooks" by calling additional virtual methods from play</li>
                  <li>all this can be done without changing the public interface</li>
                </ul>

                <h2 id="9">Visitor Pattern</h2>
                <a href="http://wikivisually.com/wiki/Architectural_pattern_(computer_science)"><img src="../images/visitor.png" /></a><br />
                The <b>visitor pattern</b> is used to perform an extensible set of operations on an object structure without requiring any change to the structure.  It can also be used to add functionality to existing classes without changing or recompiling classes. It allows us to create separate algorithms for different subclasses of the Element class by overloading the <code>visit()</code> method for each element class.  The general structure has:
                <ol>
                  <li>
                    AbstractVisitor
                    <ul>
                      <li>interface that defines the logic supported</li>
                      <li>creates a <code>visit(ConcreteElement)</code> method for each <code>AbstractElement</code> derived type</li>
                      <li>coupled with <code>ConcreteElement</code></li>
                    </ul>
                  </li>
                  <li>
                    ConcreteVisitor
                    <ul>
                      <li>implements <code>AbstractVisitor</code> and its <code>visit()</code> methods</li>
                      <li>Each <code>ConcreteVisitor</code> represents a different logic</li>
                      <li>create a class for each operation to be performed on the Element objects</li>
                    </ul>
                  </li>
                  <li>
                    AbstractElement
                    <ul>
                      <li>interface that defines the elements in the strucure</li>
                      <li>creates an <code>accept(AbstractVisitor)</code> method that takes in an <code>AbstractVisitor</code></li>
                      <li>coupled with <code>AbstractVisitor</code></li>
                    </ul>
                  </li>
                  <li>
                    ConcreteElement
                    <ul>
                      <li>implements <code>AbstractElement</code> and its <code>accept()</code> methods</li>
                      <li>Each <code>ConcreteElement</code> represents a different structure</li>
                      <li>Implments the <code>accept(AbstractVisitor)</code> method by calling <code>visit(*this)</code> on the <code>AbstractVisitor</code> argument, which will apply the logic.
                      </li>
                    </ul>
                  </li>
                </ol>
<pre class="prettyprint">
// AbstractElement
class Book {
public:
  virtual void accept(BookVisitor &v) = 0;
};

// ConcreteElement
class Novel : public Book {
public:
  Novel(std::string author) : author { author } {}
  void accept(BookVisitor &v) override { v.visit(*this); }
  std::string getAuthor() { return author; }
private:
  std::string author;
};

// ConcreteElement
class Text : public Book {
public:
  Text(std::string topic) : topic { topic } {}
  void accept(BookVisitor &v) override { v.visit(*this); }
  std::string getTopic() { return topic; }
private:
  std::string topic;
};

// ConcreteElement
class Comic : public Book {
public:
  Comic(std::string hero) : hero { hero } {}
  void accept(BookVisitor &v) { v.visit(*this); }
  std::string getHero() { return hero; }
private:
  std::string hero;
};

// AbstractVisitor
class BookVisitor {
public:
  virtual void visit(Book &b) = 0;
  virtual void visit(Text &t) = 0;
  virtual void visit(Comic &c) = 0;
};

// ConcreteVisitor
// Tracks how many of each type of book
// Groups novels by author, texts by topic, comics by hero
class Catalog : public BookVisitor {
  map<string, int> theCatalog;
public:
  map<string, int> getCatalog() { return theCatalog; }
  void visit(Book &b) { ++theCatalog[b.getAuthor()]; }
  void visit(Text &t) { ++theCatalog[t.getTopic()]; }
  void visit(Comic &c) { ++theCatalog[t.getHero()]; }
};

int main() {
  std::vector&lt;Book> books;
  Novel harryPotter("J.K. Rowling");
  Text ctci("Programming");
  Comic spider("Spider-Man");

  books.push_back(harryPotter);
  books.push_back(ctci);
  books.push_back(spider);

  Catalog log;

  // call accept on each element and passing in visitor object
  for (auto& book : books) {
    book.accept(log);
  }
}</pre>
                <h2 id="10">PImpl Idiom</h2>
                The <b>PImpl (Pointer to Implementation) Idiom</b> is a C++ programming technique that hides the implementation details of a class by placing them in a separate class, which is accessed through an opaque pointer.
<pre class="prettyprint">
/* class.h */
class Class {
    // public methods
    void foo();
private:
    class Private; // forward declaration
    Private *pImpl;   // hide impl details
};

/* class.cc */
#include "class.h"
class Class::Private {
  // include actual class implementation
  void secretFoo() {}
}
Class::Class() : pImpl { new Private } {}
Class::~Class() { delete pImpl; }
void Class::foo() { pImpl->secretFoo(); }
</pre>
                We can forward declare the <code>Private</code> class because it is only used in the declaration of a pointer.  Also note that any method in <code>Class</code> can have access to methods in <code>Private</code>, but the client does not know the implementation since <code>Private</code> hides the methods.

                <h3>Benefits of PImpl Idiom</h3>
                <ol>
                  <li>Fully-encapsulates a module</li>
                  <li>Hides implementation from client</li>
                  <li>Produces a stable interface</li>
                  <li>More readable class definitions</li>
                  <li>Hide implementation of <a href="./class.html#csi">Copy-Swap Idiom</a> and <a href="./class.html#move">move operations</a>.  This allows the assignment operators to be implemented <code>inline</code> without compromising encapsulation.
<pre class="prettyprint">
class Class {
    // ...
    Class(const Class& other) {
      // calls copy ctor of Private class
      Private *pImpl = new Private(*(other->pImpl));
    }
    void swap(Class &other) {
        std::swap(pImpl, other.pImpl);
    }
    // Copy and Swap
    Class & operator=(const Class & other) {
        // call copy ctor of Class
        Class temp(other);
        swap(temp);
        return *this;
    }
    // Move Semantics
    Class(Class&& other) : pImpl(other.pImpl) { other.pImpl = nullptr; }
    Class & operator=(Class && other) {
        std::swap(pImpl, other.pImpl);
        return *this;
    }
    // ...
};</pre>
                  </li>
                </ol>

                <h2 id="11">Model-View-Controller(MVC) Pattern</h2>
                Consider the following example:
<pre class="prettyprint">
class ChessBoard {
  istream &in ;
  ostream &out;
public:
  ChessBoard(istream &in, ostream &out) : in{in}, out{out} {
    cout << "you move";
  }
}</pre>
                <br />
                <b>Single Responsibility Principle</b>: A class should have only one reason to change<br /><br />
                The chessBoard class should not be doing any communication at all. All user interactions should be confined outside the game class.  This allows for total freedom to change how the game interacts.  Also, as a rule of thumb, <code>main</code> should not be used to handle the interactions as you may want to reuse or extend the communication code (hard to reuse code inside main).  A solution is to separate the logic and the display, and have a class to manage interactions, such as the MVC pattern.<br /><br />
                The <b>MVC pattern</b> is an architectural pattern that separates an application into three main logical components:
                <ol>
                  <li>Model
                    <ul>
                      <li>the "brains"</li>
                      <li>handles the data-related logic that the user works with</li>
                      <li>can have multiple views (text, graphics)</li>
                      <li>doesn't need to know about their details</li>
                      <li>if an observer pattern is used, it plays the role of <code>Subject</code>.  Else, it communicates through the Controller</li>
                    </ul>
                  </li>
                  <li>View
                    <ul>
                      <li>the "display"</li>
                      <li>used for the UI logic</li>
                    </ul>
                  </li>
                  <li>Controller
                    <ul>
                      <li>the "interface" between Model and View components</li>
                      <li>mediates communication between Model and View</li>
                      <li>may encapsulate turn-taking or entire game rules (tradeoff with Model)</li>
                      <li>handles user input from View and updates Model</li>
                    </ul>
                  </li>
                </ol>

                <h2 id="12">Strategy Pattern</h2>
                <a href="https://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Strategy"><img src="../images/strategy.png" /></a><br />
                The <b>strategy pattern</b> is used to provide a means to define a family of algorithms, encapsulate each one and make them interchangeable.  It allows the client to change the algorithm used dynamically.  The general structure has:
                <ol>
                  <li>AbstractStrategy
                    <ul>
                      <li>interface that provides the client with the generic algorithm</li>
                      <li>base abstract class that the family of algorithms derive from</li>
                    </ul>
                  </li>
                  <li>ConcreteStrategy
                    <ul>
                      <li>implements <code>AbstractStrategy</code></li>
                      <li>each class provides its own implementation of the algorithm provided by <code>AbstractStrategy</code></li>
                    </ul>
                  </li>
                </ol>
<pre class="prettyprint">
// AbstractStrategy
class Sort {
public:
  virtual void sort(int arr[]) = 0;
}

// ConcreteStrategy
class Merge : public Sort {
public:
  // virtual
  void sort(int arr[]) { // merge sort }
}

// ConcreteStrategy
class Quick : public Sort {
public:
  // virtual
  void sort(int arr[]) { // quick sort }
}

// ConcreteStrategy
class Bogo : public Sort {
public:
  // virtual
  void sort(int arr[]) { // bogo sort }
}

class Select {
public:
  enum SortType { Merge, Quick, Bogo };
  Select() : strategy { nullptr } {}
  void setStrategy(int type);
  void sort(int arr[]);
private:
  Sort *strategy;
}

int main() {
  Select select;
  int nums[5];
  for (int &i : nums) {
    cout << "Enter a number:" << endl;
    cin >> i;  // Not exception-safe
  }
  cout << "Select a sort type: Merge(0) Quick(1) Bogo(2) Quit(3)";
  int choice;
  cin >> choice;
  if (choice == 3) return 0;
  select.setStrategy(choice);
  select.sort(nums);
  for (int i : nums) cout << i << " ";
  return 0;
}
</pre>

              </div>
            </div>
        </div>
        <footer class="footer">
          <a href="#top">Back to Top</a>
          <p id="last_modified"></p>
        </footer>
      </div>
      <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- JS Script -->
    <script src="../../js/scripts.js"></script>

  </body>
</html>
