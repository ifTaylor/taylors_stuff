<!DOCTYPE html>
<html>
  <head>
    <title>CS 246 :: Structures & Classes</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, shrink-to-fit=no, initial-scale=1">
    <meta name="Course Notes" content="">
    <meta name="Raphael" content="">

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/simple-sidebar.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=cpp&lang=bsh&skin=sunburst"></script>
  </head>
  <body>
    <div id="wrapper">
      <!-- Sidebar -->
      <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
          <li class="sidebar-brand">
            <a href="./home.html">CS 246 Home</a>
          </li>
          <li><a href="#1">Structures</a></li>
          <li><a href="#2">Classes</a></li>
          <li><a href="#3">Class Member Functions</a></li>
          <li><a href="#4">Public and Private Members</a></li>
          <li><a href="#5">Class Initialization</a></li>
          <li><a href="#6">Accessor and Mutator Functions</a></li>
          <li><a href="#7">Structures vs. Classes</a></li>
          <li><a href="#8">Constructors</a></li>
          <li><a href="#9">Destructors</a></li>
          <li><a href="#10">Copy Constructor</a></li>
          <li><a href="#11">Copy Assignment Operator</a></li>
          <li><a href="#12">Explicit Type Conversion</a></li>
          <li><a href="#13">Move Constructor</a></li>
          <li><a href="#14">Move Assignment Operator</a></li>
          <li><a href="#15">Copy/Move Elision</a></li>
          <li><a href="#16">Static Modifer</a></li>
          <li><a href="#17">Friend Classes</a></li>
          <li><a href="#18">Forward Class Declaration</a></li>
          <li><a href="#19">Preconditions, Postconditions, Invariants</a></li>
          <li><a href="#20">Unified Modeling Language (UML)</a></li>
        </ul>
      </div>
      <!-- /#sidebar-wrapper -->

      <!-- Page Content -->
      <div id="page-content-wrapper">
          <div class="container-fluid">
            <div class="row">
              <div class="col-lg-12">
                <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toggle Menu</a>
                <h1 id="title_text">Structures & Classes</h1><br />

                <!-- Table of Contents -->
                <div id="contents">
                  <h1>Table of Contents</h1>
                  <ol id="nav">
                    <li><a href="#1">Structures</a></li>
                    <li><a href="#2">Classes</a></li>
                    <li><a href="#3">Class Member Functions</a></li>
                    <li><a href="#4">Public and Private Members</a></li>
                    <li><a href="#5">Class Initialization</a></li>
                    <li><a href="#6">Accessor and Mutator Functions</a></li>
                    <li><a href="#7">Structures vs. Classes</a></li>
                    <li><a href="#8">Constructors</a></li>
                    <li><a href="#9">Destructors</a></li>
                    <li><a href="#10">Copy Constructor</a></li>
                    <li><a href="#11">Copy Assignment Operator</a></li>
                    <li><a href="#12">Explicit Type Conversion</a></li>
                    <li><a href="#13">Move Constructor</a></li>
                    <li><a href="#14">Move Assignment Operator</a></li>
                    <li><a href="#15">Copy/Move Elision</a></li>
                    <li><a href="#16">Static Modifer</a></li>
                    <li><a href="#17">Friend Classes</a></li>
                    <li><a href="#18">Forward Class Declaration</a></li>
                    <li><a href="#19">Preconditions, Postconditions, Invariants</a></li>
                    <li><a href="#20">Unified Modeling Language (UML)</a></li>
                  </ol>
                </div>
                <!--Table of Contents -->

                <h2 id="1">Structures</h2>
                Structures are another form of "aggregate" data type, like arrays.  It differs from arrays in that it allows for a collection of values of <i>different</i> types.  Structs, like arrays, are treated as a single item.  One major difference is that a struct <u>must</u> be <i>defined</i> prior to declaring any variables.
                <h3>Defining a Struct</h3>
                When a struct is defined, no memory is allocated.  It is a "placeholder" for what the struct will look like.  The structure definition will have a list of member names in the enclosing braces.  Note that a semi-colon must follow the closing brace.  An example of a structure definition is:
<pre class="prettyprint">
struct CDAccount {  // struct keyword
  // member names
  double balance;
  double interestRate;
  int term;
};  // Dont forget semi-colon
</pre>
                <h3>Initializing a Struct</h3>
                Structures can be initialized at declaration:
                <code class="prettyprint">CDAccount account = { 12.50, 0.05, 3 };</code><br />
                The initialization provides the initial data to all member variables.

                <h3>Accessing a Struct</h3>
                Once a structure definition is given, the structure type can be used to declare <b>structure values</b>, which is a collection of <b>member values</b> (one for each member name).  These <b>structure variables</b> can be accessed with the dot operator <code>.</code>: e.g.
<pre class="prettyprint">
CDAccount account;  // declaration
account.balance;  // accesses "balance" member variable
</pre>
                <h3>Structure Assignment</h3>
                Given 2 objects of the same structure type, assignments copy each member variable from one to the other.  e.g. <code class="prettyprint">account1 = account2;</code>


                <h2 id="2">Classes</h2>
                Classes are like structures with <b>member functions</b>.  The value of a class variable is called an <b>object</b>. Classes are integral to OOP whose focus is on objects containing data and operations.

                The definition of a class is very similar to that of structures:
<pre class="prettyprint">
class DayofYear {
public:
  int month;
  int day;
  void output();  // member function
};  // Don't forget semicolon</pre>
                Declaring objects is the same as other variables, e.g. <code class="prettyprint">DayofYear today, birthday;</code><br />
                Objects include:
                <ul>
                  <li>
                    Data - Member variables
                  </li>
                  <li>
                    Operations - Member functions
                  </li>
                </ul>

                Class member variables are accessed in the same way as structs, with the dot operator. e.g. <code class="prettyprint">today.output();</code> invokes the member function <code>output()</code> of the object <code>today</code>.

                <h2 id="3">Class Member Functions</h2>
                Class member functions must be defined/implemented after the class definition.  Typically, function declarations are placed in the interface file while the implementations are kept elsewhere (information hiding).<br />
                Syntax: <code class="prettyprint">Return_Type Class_Name::Function_Name Parameter_List){}</code>
                <br />Notice the <b>scope resolution operator</b> <code>::</code>.  It tells the compiler which class the member is from.  The item before <code>::</code> (the class name) is called the <b>type qualifier</b>. e.g.
<pre class="prettyprint">
void DayofYear::output() {
  cout << "Month: " << month << ", Day: " << day;
}
</pre>

                <h3>Classes and OOP</h3>
                <ol>
                  <li>
                    Information Hiding
                    <ul>
                      <li>
                        Details of how operations work are not known to users
                      </li>
                      <li>
                        Accomplished by restricting access to member variables (private/protected)
                      </li>
                    </ul>
                  </li>
                  <li>
                    Data Abstraction
                    <ul>
                      <li>
                        User knows how to use ADT/class, but details of how data is manipulated within ADT/class is not known to user
                      </li>
                      <li>
                        Can be used as a technique for identifying which information should be hidden
                      </li>
                    </ul>
                  </li>
                  <li>
                    Encapsulation
                    <ul>
                      <li>
                        Aggregates data and operations but keeps some details hidden (through information hiding) and others visible
                      </li>
                      <li>
                        Objects are an encapsulation of data values and operations
                      </li>
                    </ul>
                  </li>
                </ol>

                <h2 id="4">Public and Private Members</h2>
                <h3>Private Members</h3>
                Member variables in classes are <b>private</b> by default (opposite of structures whose members are public by default), or under the <code class="prettyprint">private:</code> tag, which means they are accessible only inside the class.  They cannot be accessed outside the class definition via the dot operator.  This upholds the principles of OOP as it hides data from the client and allows manipulation only through public member functions.
                <h3>Public Members</h3>
                Public member variables are specified under the <code class="prettyprint">public:</code> tag, which makes them accessible from outside the class by the client through the dot operator. e.g.
<pre class="prettyprint">
class DayofYear {
public:
  void input();
  void output();
private:
  int month;  // data is private
  int day;
};
DayofYear date;
cin >> date.month;  // not allowed
date.input();  // allowed
</pre>
                <h2 id="5">Class Initialization</h2>
                <h3>Member Initialization</h3>
                Member initialization allow us to set default values for member vars by initializing them within the class definition.
                <pre class="prettyprint">
class DayofYear {
  int month = 1;  // member initialization
  int day = 1;
};</pre>
                <h3>Uniform Initialization</h3>
                Classes can be initialized similar to arrays: <code class="prettyprint">int arr[4] = { 0, 1, 2, 3 };</code>
                For a class with only public vars:
<pre class="prettyprint">
class Student {
public:
  String name;
  int id;
}
Student s1 = { "Sarah", 1222 };  // aggregate initialization</pre>
                For a class with private vars, we need to define a constructor to initialize the private vars.
<pre class="prettyprint">
class Student {
private:
  String name;
  int id;
public:
  Student(String name, int id) : name {name}, id {id} {}
}
Student s2 = { "John", 3344 };  // calls constructor</pre>
                Uniform Initialization searches for:
                <ol>
                  <li>
                    initializer_list constructor, i.e. <code class="prettyprint">myclass (std::initializer_list&lt;int> v);</code>
                  </li>
                  <li>
                    Regular constructors
                    <ul>
                      <li>private member vars</li>
                      <li>public constructor</li>
                    </ul>
                  </li>
                  <li>
                    Aggregate Initialization (with public member vars)
                  </li>
                </ol>

                <h3>Member Initialization List</h3>
                Fields are initialized in the order of declaration in the class, not in the order of MIL.  This is more efficient than initializing in the body as it calls the constructor once rather than calling the default constructor and then initializing the member vars.  (More <a class="link" href="#init">later</a>.)

                <h2 id="6">Accessor and Mutator Functions</h2>
                Accessor and Mutator functions are used to set/modify and retrieve the private member data of objects.
                <ul>
                  <li>
                    Accessor Functions - allows client to retrieve data from object.  Should not change class data (represented by making function a constant function via <code>const</code> keyword after function parameter list.  Explained more <a href="./function.html#6">here</a>.)
                  </li>
                  <li>
                    Mutator Function - allows client to change the data
                  </li>
                </ul>
<pre class="prettyprint">
class DayofYear {
public:
  void input();
  void output();
  // Mutator Functions
  void setMonth (int month);
  void setDay (int day);
  // Accessor Functions
  int getMonth() const;
  int getDay() const;
private:
  int month;  // data is private
  int day;
};</pre>


                <h2 id="7">Structures vs. Classes</h2>
                <table>
                  <tr>
                    <th>Property</th>
                    <th></th>
                    <th>Structure</th>
                    <th>Class</th>
                  </tr>
                  <tr>
                    <td>Default Scope</td>
                    <td></td>
                    <td>Public</td>
                    <td>Private</td>
                  </tr>
                  <tr>
                    <td>Member Functions</td>
                    <td></td>
                    <td>None</td>
                    <td>Interface member functions are public</td>
                  </tr>
                </table>

                <h2 id="8">Constructors</h2>
                Constructors are member functions that are called when an object of that class is declared.  It initializes some or all member variables.  It can also be used to validate the data provided to ensure that the appropriate data is assigned to the member variables.  A constructor is defined like any other function except:
                <ol>
                  <li>
                    must have the same name as class
                  </li>
                  <li>
                    cannot return a value.  They return an anonymous object (for example, overloaded functions returning a new object as seen <a href="./function.html#8">here</a>).
                  </li>
                  <li>
                    no type given (not even void)
                  </li>
                </ol>
                We can then declare objects of that type with the initialization parameters provided.  Note that we cannot call constructors like other member functions.
<pre class="prettyprint">
class DayofYear {
public:
  DayofYear(int month, int day); // ctor initializes month and day
private:
  int month;  // data is private
  int day;
};
DayofYear date1(3, 14), date2(2, 29);
// The following is ILLEGAL
DayofYear date1;
date1.DayofYear(7, 4);
</pre>
                A contructor definition looks like this:
<pre class="prettyprint">
DayofYear::DayofYear(int monthValue, int dayValue) {
  month = monthValue;
  day = dayValue;
}</pre>
                <h3 id="init">Initialization Section</h3>
                We can also use an <b>initialization section</b> to initalize member data.  The initialization section is placed after the parameter list and before the opening braces.  It consists of a colon followed by a list of some or all member vars separated by commas. Each member varaiable included is then followed by its initializing value in parenthesis.  This is favoured over the other method as it is more efficient: less overhead (explained later). e.g.
<pre class="prettyprint">
DayofYear::DayofYear(int monthValue, int dayValue)
  : month(monthValue), day(dayValue) {}</pre>

                <h3>Overloaded Constructors</h3>
                Constructors can also be overloaded like other functions.  This allows for multiple contructors of different parameters.  The <i>default</i> constructor (without parameters) should <u>not</u> be declared with any brackets, else the compiler will mistake it for a function.
<pre class="prettyprint">
DayofYear date1;  // Correct
DayofYear date1(); // Wrong
</pre>
                <h3>Constructor Delegation</h3>
                When dealing with multiple constructors, we might encounter repetitive code across constructors.  To reduce this, we can apply <b>constructor delegation</b>.  We call the constructor we are delegating to as the <i>only</i> item in the initialization section.
<pre class="prettyprint">
class Max {
  int max, min, middle;
};
Max::Max(int my_max) {
  max = my_max > 0 ? my_max : 10;
}
Max(int my_max, int my_min) : Max(my_max) {
  min = my_min > 0 && my_min < max ? my_min : 1;
}
Max(int my_max, int my_min, int my_middle) : Max (my_max, my_min){
  middle = my_middle < max && my_middle > min ? my_middle : 5;
}</pre>

                <h3>Explicit Constructor Calls</h3>
                Constructors can be called even after object has been declared. e.g. <code class="prettyprint">holiday = DayofYear(5, 5);</code><br />
                Note that for the default constructor with no arguments, we <u>do</u> have to include parenthesis this time.

                <h3>Default Constructor</h3>
                The <b>default constructor</b> is the constructor without any arguments.  It is auto-generated only if no other constructors are defined.  As a rule, it should always be defined to allow for accidental declarations of classes without parameters, i.e. <code class="prettyprint">DayofYear date;</code>

                <div class="note">
                  <div>
                    <h3>The Big 3</h3>
                    The big 3 consists of:
                    <ul>
                      <li>Destructor</li>
                      <li>Copy Constructor</li>
                      <li>Copy Assignment Operator</li>
                    </ul>
                    It is a rule of thumb of C++ for building exception-safe code and for formalizing rules on resource management.
                    It claims that if a class defines one (or more) of the following, it should probably explicitly define all three.
                  </div>
                </div>
                <h2 id="9">Destructors</h2>
                Destructors are executed whenever an object of its class goes out of scope or is deallocated by the <code>delete</code> operator.
                <br />Syntax: <code class="prettyprint">~className(){}</code><br />
                Its default version only destroys regular variables and not dynamic variables.

                <h2 id="10">Copy Constructor</h2>
                A copy constructor is used when a copy of an object is made, in the following situations:
                <ol>
                  <li>
                    A class object is declared and initialized by another object of the same type in parameters. e.g.
                    <ul>
                      <li><code class="prettyprint">Class c1(c2);</code></li>
                      <li><code class="prettyprint">Class c1 = c2;</code></li>
                    </ul>
                  </li>
                  <li>
                    When a function returns a value of the class type.
                  </li>
                  <li>
                    When an argument of the class type is plugged in for a call-by-value parameter
                  </li>
                </ol>
                The copy constructor has one call-by-reference parameter of same class type (normally const).  Any class that uses pointers/new operator should have a copy constructor.
<pre class="prettyprint">
Class::Class(const Class& Object) {
  ptr = new int;
  *ptr = Object->ptr; // copies value over
}</pre>

                <h2 id="11">Copy Assignment Operator</h2>
                This is called when an already initialized object is assigned a new value from another existing object.  This is a fallback for move assignment when move is unavailable (rvalues can bind to const references)
<pre class="prettyprint">
Class &Class::operator=(const Class &Object) {
  if (this != &Object){
    // get rid of old data
    delete ptr;
    ptr = nullptr;
    // copy over values
    ptr = new int;
    *ptr = Object->ptr;
    return *this;
  }
}
Class c2 = c1;  // calls copy constructor</pre>

                <h3 id="csi">Copy And Swap Idiom</h3>
                The <b>copy and swap idiom</b> provides a strong exception guarantee for resource managing class.  Normally, copying is done as follows:
                <ol>
                  <li>Check for self-assignment</li>
                  <li>Free up memory</li>
                  <li>Allocate new memory</li>
                  <li>Deep copy similar to copy constructor</li>
                </ol>
                For example, in a LinkedList:
<pre class="prettyprint">
struct Node {
private:
  Node *next;

public:
  Node &operator =(const Node &other) {
    if (this != &other) {
      delete next;
      next = other.next ? new Node (*other.next) : nullptr;
      return *this;
    }
  }
}</pre>
                This method does not leak memory, however, it has 3 disadvantages:
                <ol>
                  <li>
                    Self-assignment rarely occurs, slows program down to check.  Would be better if it could work regardless.
                  </li>
                  <li>
                    Only provides a basic exception guarantee. It does <u>not</u> maintain the state of the object when an exception is thrown. If <code>new</code> fails, <code>next</code> has lost its data.
                  </li>
                  <li>
                    Duplicates code written elsewhere.
                  </li>
                </ol>
                To solve this, we use the copy and swap idiom, as follows:
<pre class="prettyprint">
#include &lt;utility>  // swap
struct Node {
private:
  Node *next;
  int data;
public:
  void swap(Node &other){
    using std::swap;
    swap(data, other.data); // data now contains other.data, other.data contains your data
    swap(next, other.next);
  }
  Node &operator =(const Node &other) {
    Node temp = other;  // copy constructor
    swap(temp);  // swap temp with this
    return *this;
  }
}
</pre>
                Note that the above 3 disadvantages are solved:
                <ol>
                  <li>
                    Works even with self-assignment due to <code>temp</code>
                  </li>
                  <li>
                    Provides a strong exception guarantee.  If <code>new</code> fails, we won't even reach the point of the function where the current object is being altered.  <code>swap</code> is non-throwing and the temp variable will be destroyed when the function ends.
                  </li>
                  <li>
                    This idiom does not repeat code, thus we cannot introduce bugs.
                  </li>
                </ol>

                <h2 id="12">Explicit Type Conversion</h2>
                <h3>Implicit Type Conversion</h3>
                By default, copy constructors are <b>implicit</b>.  This means that a type conversion can be done if there is a constructor with that type.  For example,
<pre class="prettyprint">
struct Node {
  Node(int data) : data {data}, next{nullptr} {}
};
// explicit type conversions calls ctor
Node n(4);
Node n = 4;</pre>
                <h3>Explicit Type Conversion</h3>
                To prevent the compiler from using constructors to perform implicit conversions, we prepend the <code>explicit</code> keyword to the constructor.  One reason to do so is to avoid accidental construction of the object with other types.
<pre class="prettyprint">
struct Node {
  explicit Node(int data) : data {data}, next{nullptr} {}
};
Node n(4);   // OK
Node n = 4;  //Not OK</pre>

                <div class="note">
                  <div>
                    <h3>The Big 5</h3>
                    The Big 5 is an extension of the Big 3, implemented in C++11.  It consists of:
                    <ul>
                      <li>Destructor</li>
                      <li>Copy Constructor</li>
                      <li>Move Constructor</li>
                      <li>Copy Assignment Operator</li>
                      <li>Move Assignment Operator</li>
                    </ul>
                    It implements move semantics, allowing destination objects to grab data from temporary objects.
                  </div>
                </div>

                <h2 id="13">Move Constructor</h2>
                <h3 id="move">Move Semantics</h3>
                Copying was the means to transfer the state of an object to another. Moving is faster as they move existing resources to the new destination and sets the other to the default constructor, while copying requires the creation of a new resource from scratch.  The lack of allocation and copying makes it faster and more efficient than copying.
                <h3>The Move Constructor</h3>
                The move constructor removes need for deep copy or <code>delete</code>.   Takes in an r-value reference (see <a href="./pointer.html#lrvalue">here</a>). <code>std::move()</code> is a cast that can be applied on an l-value argument to produce an rvalue reference. e.g.
<pre class="prettyprint">
MemoryPage (MemoryPage &&other) : size(0), buf(nullptr) {
  // pilfers other's resources
  size = other.size;
  buf = other.buf;
  // reset other
  other.size = 0;
  other.bug = nullptr;
}</pre>

                <h2 id="14">Move Assignment Operator</h2>
                Similar to move constructor except that before pilfering source object, it releases any resources the object might own.  Performs the following steps:
                <ol>
                  <li>Releases source object <code>*this</code> currently owns</li>
                  <li>Pilfers <code>other</code>'s resources</li>
                  <li>Set <code>other</code> to a default state</li>
                  <li>return <code>*this</code></li>
                </ol>
<pre class="prettyprint">
MemoryPage& MemoryPage::operator=(MemoryPage&& other){
  if (this != &other) {
    // release the current object’s resources
    delete[] buf;
    size = 0;
    // pilfer other’s resource
    size = other.size;
    buf = other.buf;
    // reset other
    other.size = 0;
    other.buf = nullptr;
  }
  return *this;
}</pre>

                <h3>Move and Swap Example</h3>
<pre class="prettyprint">
MemoryPage& MemoryPage::operator=(MemoryPage&& other){
  using std::swap;
  swap(size, other.size); // swap values of this with other (R-value to be destroyed)
  swap(buf, other.buf);
  return *this
}</pre>

                <div class="note">
                  <div>
                    Every class comes with:
                    <ol>
                      <li>default constructor</li>
                      <li>copy constructor</li>
                      <li>copy assignment operator</li>
                      <li>destructor</li>
                      <li>move constructor</li>
                      <li>move assignment operator</li>
                    </ol>
                  </div>
                </div>

                Example of a class with Big 5 implemented:
<pre class="prettyprint">
/* class.h */
class Class {
  int *ptr;
public:
  Class() {};  // default ctor
  Class(int i); // overloaded ctor
  // BIG 5
  Class(const Class &other);  // copy ctor
  Class(Class &&other);  // move ctor
  Class &operator=(const Class &other);  // copy assignment
  Class &operator=(Class &&other);  // move assignment
  ~Class();
}

/* class.cc */
// Constructors
Class::Class() : ptr { nullptr } {}
Class::Class(int i) : ptr { new int(i) } {}

// Copy Ctor
Class::Class(const Class &other) : ptr { new int(*(other.ptr)) } {}

// Move Ctor
Class::Class(Class &&other) : ptr { nullptr } {
  std::swap(ptr, other.ptr);
}

// Copy Assignment Operator
Class &Class::operator=(const Class &other) {
  Class temp(other);  // Copy Ctor
  std::swap(ptr, temp.ptr); // Copy and Swap
  return *this;
}

// Move Assignment Operator
Class &Class::operator=(Class &&other) {
  std::swap(ptr, other.ptr); // Move and Swap
  return *this;
}

// Destructor
Class~Class() { delete ptr; }</pre>

                <h2 id="15">Copy/Move Elision</h2>
                <b>Copy or move elision</b> is an optimization technique where compilers are required or permitted to omit the copy/move constructors, even if these constructors and destructors have observable side effects.  This prevents extra (potentially expensive) copies.  We can disable elision with <code>-fno-elide-constructors</code>. This should <u>not</u> be done because the elision would ignore the side effects.  If your program relies on side effects of copy constructors, it is badly written; copy constructors should be written such that elision is safe.
<pre class="prettyprint">
struct C {
  C() {}
  C(const C&) { std::cout << "A copy was made.\n"; }
};

C f() {
  return C();
}

int main() {
  std::cout << "Hello World!\n";
  C obj = f();
}</pre>
                Depending on the compiler and the level of elision, the following outputs are all valid:
                <ul>
                  <li>
<pre class="prettyprint">
Hello World!
A copy was made.
A copy was made.</pre>
                  </li>
                  <li>
<pre class="prettyprint">
Hello World!
A copy was made.</pre>
                  </li>
                  <li>
<pre class="prettyprint">
Hello World!</pre>
                  </li>
                </ul>


                <h2 id="16">Static Modifier</h2>
                <h3>Static Variables</h3>
                <b>Static member variables</b> are shared by all objects of that class.  When one object changes it, all objects sees that change. To make a variable static, we place the <code>static</code> keyword before its type. Here are some potential uses:
                <ol>
                  <li>
                    for object of a class to communicate with each other and coordinate actions.
                  </li>
                  <li>
                    track how often a member function is called across all objects
                  </li>
                  <li>
                    count how many objects exist at a given time
                  </li>
                </ol>
                Static variables are initialized <i>outside</i> the class definition.  This ensures that the class' author performs the initializing of the static variables and no other programmer can initialize them (static vars cannot be initialized twice).

                <h3>Static Functions</h3>
                Static member functions are member functions that does not need access to an object's data but still needs to be a member of that class.  It can be called outside of the class without having to have a calling object.  Note that it can only use <i>static member variables</i> and not any variable that depends on a calling object.
<pre class="prettyprint">
class DayofYear {
public:
  static void printTodayDate();
private:
  int month;
  int day;
  static int numOfDates;
};
int DayofYear::numOfDates = 0; // initialize static var
DayofYear::printTodayDate(); // call static function
</pre>

                <h2 id="17">Friend Classes</h2>
                Similar to functions being a <code>friend</code> to a class (see <a href="./function.html#9">here</a>).
                If a class <code>F</code> is a friend of class <code>>C</code>, then every member function of class <code>F</code> is a friend of class <code>C</code>.  We declare the friend class as a friend within the other class.
<pre class="prettyprint">
class F;  // forward declaration
class C {
public:
  friend class F;
};
class F {};</pre>

                <h2 id="18">Forward Class Declaration</h2>
                A <b>forward declaration</b> is a declaration of an identifier which the programmer has not yet provided a definition.
                <div class="note">
                  <div>
                    <h3>Tip:</h3>
                    Always forward declare classes instead of using headers if possible.
                  </div>
                </div>
                When we include header files, we introduce a dependency that will cause the current class to recompile whenever the header file changes.  Forward declaring classes will speed up compilation.  <br />Note, however, that when we forward declare classes, all the compiler knows is that the class exists and nothing about its size or members, thus, we cannot use it when the current class needs to know the "insides" of the forward declared class. e.g.
<pre class="prettyprint">
class F;  // forward declaration
class C {
public:
  F *ptr;  // allowed
  F obj;   // not allowed
};</pre>
              As a rule of thumb, only forward declare when:
              <ul>
                <li>Pointer</li>
                <li>Reference</li>
                <li>Parameter of function</li>
                <li>Return type of function</li>
              </ul>

              <h2 id="19">Preconditions, Postconditions, Invariants</h2>
              These are properties of classes/functions that allow us to specify what it does/accomplishes.
              <b>Preconditions</b> are conditions that must be true of the parameters of a function and/or data members, if the function is to behave correctly, <i>prior</i> to running the function.
              <b>Postconditions</b> are conditions that are true <i>after</i> the function is run.<br />
              e.g. Consider the square root function that prints to the screen: <code class="prettyprint">void sqrt(double x);</code><br />
              Precondition: <code>x >= 0</code>
              Postcondition: Square root of x is printed to screen
              <b>Invariants</b> are a set of asserts that must hold true from the creation to the destruction of objects.  For example, exactly one of two member vars must be 0.  We can use a member function to check if invariant holds and raise an assert if invariant is broken.  Encapsulation enforces invariants by making fields private and allowing us to ensure that the data is correct in the preconditions and postconditions.<br />
              <i>The pre and postconditions ensure that invariants are not violated.</i>
<pre class="prettyprint">
struct Node {
  int data;
  Node *next;
  Node(int data, Node *next) : data {data}, next{next} {}
  ~Node(){
    delete next;
  }
};
// stack-allocated
Node n1 {1, new Node{2, nullptr}};
Node n2 {3, nullptr};
Node n3 {4, &n2};</pre>
              Here's what happens when each object is pushed off the stack:
              <ol>
                <li>
                  <code>n1</code> - destructor called on n1, and its next node is deleted off heap
                </li>
                <li>
                  <code>n2</code> - now a <code>nullptr</code> so nothing happens
                </li>
                <li>
                  <code>n3</code> - undefined behaviour/crash since <code>n2</code> is being deleted
                </li>
              </ol>
              To solve this, we use encapsulation by introducing a <b>wrapper class</b>.
<pre class="prettyprint">
class List {
  struct Node; // private nested class
  Node *l = nullptr;
public:
  void addToFront(int n);
  int ith(int i);
  ~List();
};

struct List::Node {
  int data;
  Node *next;
  Node(int data, Node *next) : data{data}, next{next} {}
  ~Node() {
    delete next;
  }
};

List::~List(){
  delete l;
}

void list::addToFront(int n) {
  l = new Node(n, l);
}

int List::ith(int i){
  Node *cur = l;
  for(int j = 0; j < i && cur; ++j) {
    cur = cur->next;
    return cur->data;
  }
}</pre>


              <h2 id="20">Unified Modeling Language (UML)</h2>
              UML's show dependencies between classes.  Here are some properties:
              <ul>
                <li>class names are on top</li>
                <li><code>+</code> represents a public member</li>
                <li><code>-</code> represents a private member</li>
                <li>arrows represent inclusion of another class</li>
                <li>weak association: includes parameter of another class</li>
                <li>strong association: hold reference to an instance of another class</li>
                <li>Aggregation: shared association
                  <ul>
                    <li>
                      class B can be a part of other classes (class A is not an exclusive container of class B)
                    </li>
                    <li>use an open diamond</li>
                  </ul>
                </li>
                <li>Composition: not shared association
                  <ul>
                    <li>
                      class A has exclusive ownership over class B
                    </li>
                    <li>use a solid diamond</li>
                  </ul>
                </li>
                <li>numbers on either side of arrow to represent the multiplicity relationship</li>
                <li>Order: class name, member vars, member functions</li>
              </ul>
              Refer to this <a href="https://cppcodetips.wordpress.com/2013/12/23/uml-class-diagram-explained-with-c-samples/" target="_blank">link</a> for more information.

              </div>
            </div>
        </div>
        <footer class="footer">
          <a href="#top">Back to Top</a>
          <p id="last_modified"></p>
        </footer>
      </div>
      <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- JS Script -->
    <script src="../../js/scripts.js"></script>

  </body>
</html>
